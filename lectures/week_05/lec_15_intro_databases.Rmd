---
title: "Set up a PostgreSQL database with ecological data"
author: "Jennifer Scheuerell"
date: "5 February 2021"
output:
  html_document:
    theme: readable
    highlight: textmate
    toc: true
    toc_float: true
    toc_depth: 3
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      fig.align = "center", out.width = '90%')
```

<br>

# Background 

We [saw previously](lec_14_intro_databases.html) how to create a PostgreSQL database and schema for staging our data. Recall that we used the [Convert CSV to SQL](https://www.convertcsv.com/csv-to-sql.htm) website to generate the `CREATE TABLE` and `INSERT INTO` SQL statements used to import our csv data. We also created a `staging` schema in our database, which will allow us to write our limno data there so we can clean it up and then write the cleaned version into our final table with numeric data types. 

Here we will learn how to:

- [Create data tables](#create)

- Insert data into our tables 

- Update a table

- Clean up the data

- Modify the data

- Write data between tables

- Join our tables together in a query

- Create a view of our joined query

SQL scripts for each step are available [here](https://github.com/sureL/postgres-tutorial/tree/main/sql/ecology_example). 
As you've seen elsewhere in class, all of the SQL scripts have number prefixes to show the order in which they should be run.

# Create a data table {#create}

The first step is to create the `staging` schema limno table and insert the data from the `.csv` file. The [SQL script for this step](sql/1_create_insert_staging_limno.sql) is  and was generated by the Convert CSV to SQL website. In the conversion process, I selected:

- No primary key (uncheck **Key** for field `Year`)

- Data fields are not required (uncheck **Required** for all fields except `Year` and `Month`)

One of the essential elements to be able to join the monthly data in `limno` and `pdo` together is to have the 
fields we will use to join the tables have the same data. In the `lwa_limno.csv` we have a field for `Year` and 
a field for `Month`, but in the `pdo_data.csv` we have one field called `Date` that has the year and month 
concatenated together. We could convert either data set to match the other, I chose to convert the `limno` data 
to a concatenated year plus month value to match `pdo`. 

Data format in `limno`

Year | Month 
--|--
1990 | 1
1990 | 2

Data format in `pdo`

Date
--
199001
199002

The next thing we need to do is create a new field in the `limno` table where we can write our new year_month concatenation. 
To add a field to an existing table, we use the SQL `ALTER TABLE` command. The SQL script for this step is
`2_alter_table_staging_limno.sql`. Note that fields added to tables via the `ALTER TABLE` command are appended to the end 
of the existing table fields. 

Now that we have a field we can write our new concatenation into, we need to create SQL to concatenate two fields into one field. 
The PostgreSQL concatenation operator is double pipes `||`. Because the year and month data in the table are integers, we
need to cast their data types to text so that we can contenate them together. To cast a field to a different datatype in 
PostgreSQL, you follow the field name with double colons `::` and then the data type, e.g. `Year::text`.
If we query `limno` to try our concatenation, we can run

```
select year::text || month::text from staging.limno;
```

to check if that gives us what we need for the concatenated field. That looks pretty good, but notice that in `pdo` all of 
the values are six digits - i.e. for single digit months the month is written 01 instead of 1 - and our `limno` concatenation
doesn't match that. We need to add a zero in the concatenation, but only for our single digit months. To write conditional
logic in SQL we use the `case` statement. The `case` statement context is

```
case when XX then YY else ZZ end
```

Note that we can make case statements more complicated by nexting addional when clauses, e.g. 

```
case when XX then YY when AA then BB else ZZ end
```

So if we add to our concatenation the conditional logic to include a zero for single digit months, we have

```
select year::text || case when month < 10 then '0' else '' end || month::text from limno;
```

And now we are generating a concatenation that is always six digits and matches the `pdo` table. Now that we have the 
right SQL to create the values we want, we need to write those values into our new `year_month` field in the 
`staging.limno` table. To update data in a table we use the `UPDATE` SQL command. The SQL script for this step is 
`3_update_staging_limno.sql`.

The last step we need to do to clean up the `limno` data is to remove where the text `NA` exists in data fields. 
Since we are updating data in a table, we again will use the SQL `UPDATE` command. The SQL script for this step is 
`4_clean_up_NA_in_limno.sql`.

Now that the `staging.limno` data are cleaned up and ready to go, we need to make our final data table where the cleaned up data 
will reside. This will be an identical table to `staging.limno` except we will drop the `year` and `month` fields and take
our newly created `year_month` field instead; also that the data fields will all be numeric data types instead of text. 
The SQL scropt for this step is `5_create_table_public_limno.sql`. 

Our last step for the `limno` data is to write the data from `staging.limno` to `public.limno`. The SQL script for this step
is `6_write_clean_data_into_public_limno.sql`. 

The good news is that the `pdo` csv data are clean and can be directly written into `public.pdo`. The SQL Script for creating 
the table and inserting the data from the csv was created with the Convert CSV to SQL website. The SQL script for this step
is `7_create_insert_public_pdo.sql`.

Now we have cleaned up data in final tables ready to be queried and joined. We can now bring the `pdo` and `limno` data togehter 
into a single result set for analysis. The SQL script for this step is `8_join_pdo_limno.sql`. Run the `SELECT` query first to view
the result set and verify everything looks right. Then uncomment out the `CREATE VIEW` line at the top and run the script again 
to create a view we can reuse to access the joined data. 

