---
title: "Creating R packages"
subtitle: "Part 2"
author: "Mark Scheuerell"
date: "26 February 2021"
output:
  html_document:
    theme: readable
    highlight: textmate
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

***

# Background

We saw [last time](lec_23_packages_1.html) how to create a basic package from a simple function, document its contents, and explore its functionality. In this exercise, we'll learn how to create formal tests for our functions, write vignettes, and publish our package to the web.

***

# Testing

We spent just a bit of time testing out our `cats()` function, but we can formalize this process with so-called *unit tests*. This simply means we'll set up some expectations about the values our function should take given certain arguments. As [Wickham & Bryan](https://r-pkgs.org/tests.html) point out, there are four advantages to working with unit tests:

1) Fewer bugs and errors

2) More rigorous code structure

3) Easier start/stop points

4) Code that's robust to changes

Fortunately, `{devtools}` helps us with this process via some built-in functions. To begin, we'll use `use_testthat()` to set up our framework for testing. This function:

* adds `Suggests: testthat` to `DESCRIPTION`

* creates the directory `tests/testthat/`

* adds the script `tests/testthat.R`

```{r testthat}
use_testthat()
✓ Adding 'testthat' to Suggests field in DESCRIPTION
✓ Setting Config/testthat/edition field in DESCRIPTION to '3'
✓ Creating 'tests/testthat/'
✓ Writing 'tests/testthat.R'
● Call `use_test()` to initialize a basic test file and open it for editing.
```

Now that we have our testing framework, we need to write some actual test scripts. We'll use the `use_test()` function to create an empty script for testing our `cats()` function. 

```{r use_test}
use_test("cats")
✓ Writing 'tests/testthat/test-cats.R'
● Modify 'tests/testthat/test-cats.R'
```

You should now see a script called `test-cats.R` with the following example test in it.

```{r test_that_default}
test_that("multiplication works", {
  expect_equal(2 * 2, 4)
})
```

This example shows the hierarchical nature of unit tests. So-called *expectations* are grouped into *tests*, which are then organized into *files*. The test itself is embedded within `test_that()`, and is based upon the expected result of an operation that we associate with an `expect_` function. In the default example above, the expectation is `"multiplication works"`, and the test is whether or not `2 * 2 == 4`, which is written as `expect_equal(2 * 2, 4)`. You can find a whole battery of `{testthat}` functions [here](https://testthat.r-lib.org/reference/index.html).

Let's go ahead and write some unit tests for `cats()`. Let's use these options:

```{r unit_test_1}
test_that("logical operators work", {
  ## if TRUE
  expect_equal(cats(TRUE), "I love cats!")
  ## if alias for TRUE
  expect_equal(cats(1), "I love cats!")
  ## if FALSE
  expect_equal(cats(FALSE), "I am not a cat person.")
  ## if alias for FALSE
  expect_equal(cats(0), "I am not a cat person.")
})
```

and save our file when we're done entering the tests. Now we're set to run these tests with the `test()` function.

```{r run_test}
test()
Loading pets
Testing pets
✓ |  OK F W S | Context
⠏ |   0       | cats                                  [1] "I love cats!"
⠋ |   1       | cats                                  [1] "I love cats!"
[1] "I am not a cat person."
[1] "I am not a cat person."
✓ |   4       | cats [0.1 s]

══ Results ═══════════════════════════════════════════════════
Duration: 0.1 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]
```

The testing report indicates how many total tests were run, and how many of them failed (`FAIL`), issued a warning (`WARN`), were skipped (`SKIP`), and passed (`PASS`). Here we see that all four of our tests passed, which is good news indeed.


***

# Packages on GitHub

The `pets` repo we created on **GitHub** contains our package skeleton in human-readable form. One of the neat things about this is that you (or anyone else) can now install the package directly from **GitHub** using either of these calls (replacing `YOUR_GITHUB_USERNAME` with your actual **GitHub** username):

```{r install_gh}
## original call using {devtools} still works
devtools::install_github("YOUR_GITHUB_USERNAME/pets")

## but {remotes} is the newer package with the function
remotes::install_github("YOUR_GITHUB_USERNAME/pets")
```

Note that if you try either of these commands and get the following error

```
Using github PAT from envvar GITHUB_PAT
Error: Failed to install 'pets' from GitHub:
  HTTP error 401.
  Bad credentials
```

go ahead a run `Sys.unsetenv("GITHUB_PAT")` and then try again.

## Editing README

Because our package now lives in a public space where others can find and use it, we should include some helpful information in the `README.md` file to describe the package contents and how it works. We can use the `use_readme_rmd()` function to create a **Markdown** file with a skeleton for us add information about our package.

```{r use_readme}
use_readme_rmd()
✓ Writing 'README.Rmd'
✓ Adding '^README\\.Rmd$' to '.Rbuildignore'
● Modify 'README.Rmd'
✓ Writing '.git/hooks/pre-commit'
```

The output above indicates that the function

* created `README.Rmd`

* added some lines to `.Rbuildignore`

* created a **Git** *pre-commit hook* to keep `README.Rmd` and `README.md` synced with one another

Let's go ahead and inspect the content of `README.Rmd`. You will see a number of sections with prompts asking for more information about the package, including a description of the package, how to install it, and example of its usage. Note that comments in **Markdown** are denoted by `<!-- some comment here -->`.

In the first section `# pets`, go ahead and enter some descriptive text about the package contents (you can delete the comments about badges). For example,

```
# pets

The goal of pets is to provide a simple means for people to express their feelings about pets. At present, the packge only contains one function: `cats()`.
```

In the next section on `## Installation`, delete the information about installing from **CRAN**, as our package doesn't exist there. You will note that the installation instructions for **GitHub** are already included.

````
## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("mdscheuerell/pets")
```
````

In the `## Example` section, fill in some information with example calls to `cats()`. For example,

````
## Example

Here are two simple examples that allow you to express your feelings about cats:

`r ''````{r example}
library(pets)

## if you like cats
cats(TRUE)

## if you don't like cats
cats(FALSE)
```
````

When you are finished editing `README.Rmd`, you can either knit it directly from within **RStudio** or uee the `build_readme()` function.

```{r build_ _readme}
build_readme()
Installing pets in temporary library
Building /Users/scheuerl/Documents/GitHub/pets/README.Rmd
```

Now go ahead and commit **both** `README.Rmd` **and** `README.md`, and then push them to **GitHub**. When you are finished, check out your `pets` repo on **GitHub** to see the new changes to your `README.md`.

***

# Vignettes


***

# Website


***

# Hex sticker





