---
title: "Creating R packages"
subtitle: "Part 2"
author: "Mark Scheuerell"
date: "26 February 2021"
output:
  html_document:
    theme: readable
    highlight: textmate
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

***

# Background

We saw [last time](lec_23_packages_1.html) how to create a basic package from a simple function, document its contents, and explore its functionality. In this exercise, we'll learn how to create formal tests for our functions, write vignettes, and publish our package to the web.

***

# Testing

We spent just a bit of time testing out our `cats()` function, but we can formalize this process with so-called *unit tests*. This simply means we'll set up some expectations about the values our function should take given certain arguments. As [Wickham & Bryan](https://r-pkgs.org/tests.html) point out, there are four advantages to working with unit tests:

1) Fewer bugs and errors

2) More rigorous code structure

3) Easier start/stop points

4) Code that's robust to changes

Fortunately, `{devtools}` helps us with this process via some built-in functions. To begin, we'll use `use_testthat()` to set up our framework for testing. This function:

* adds `Suggests: testthat` to `DESCRIPTION`

* creates the directory `tests/testthat/`

* adds the script `tests/testthat.R`

```{r testthat}
use_testthat()
✓ Adding 'testthat' to Suggests field in DESCRIPTION
✓ Setting Config/testthat/edition field in DESCRIPTION to '3'
✓ Creating 'tests/testthat/'
✓ Writing 'tests/testthat.R'
● Call `use_test()` to initialize a basic test file and open it for editing.
```

Now that we have our testing framework, we need to write some actual test scripts. We'll use the `use_test()` function to create an empty script for testing our `cats()` function. 

```{r use_test}
use_test("cats")
✓ Writing 'tests/testthat/test-cats.R'
● Modify 'tests/testthat/test-cats.R'
```

You should now see a script called `test-cats.R` with the following example test in it.

```{r test_that_default}
test_that("multiplication works", {
  expect_equal(2 * 2, 4)
})
```

This example shows the hierarchical nature of unit tests. So-called *expectations* are grouped into *tests*, which are then organized into *files*. The test itself is embedded within `test_that()`, and is based upon the expected result of an operation that we associate with an `expect_` function. In the default example above, the expectation is `"multiplication works"`, and the test is whether or not `2 * 2 == 4`, which is written as `expect_equal(2 * 2, 4)`. You can find a whole battery of `{testthat}` functions [here](https://testthat.r-lib.org/reference/index.html).

Let's go ahead and write some unit tests for `cats()`. Let's use these options:

```{r unit_test_1}
test_that("logical operators work", {
  ## if TRUE
  expect_equal(cats(TRUE), "I love cats!")
  ## if alias for TRUE
  expect_equal(cats(1), "I love cats!")
  ## if FALSE
  expect_equal(cats(FALSE), "I am not a cat person.")
  ## if alias for FALSE
  expect_equal(cats(0), "I am not a cat person.")
})
```

and save our file when we're done entering the tests. Now we're set to run these tests with the `test()` function.

```{r run_test}
test()
Loading pets
Testing pets
✓ |  OK F W S | Context
⠏ |   0       | cats                                  [1] "I love cats!"
⠋ |   1       | cats                                  [1] "I love cats!"
[1] "I am not a cat person."
[1] "I am not a cat person."
✓ |   4       | cats [0.1 s]

══ Results ═══════════════════════════════════════════════════
Duration: 0.1 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]
```

The testing report indicates how many total tests were run, and how many of them failed (`FAIL`), issued a warning (`WARN`), were skipped (`SKIP`), and passed (`PASS`). Here we see that all four of our tests passed, which is good news indeed.


***

# Vignettes


***

# Website


***

# Hex sticker





